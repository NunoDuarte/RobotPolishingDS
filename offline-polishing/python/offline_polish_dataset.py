#!/usr/bin/env python3
# in the terminal do "source catkin/devel/setup.bash
# to add the kortex_driver to the directory

from scipy.optimize import minimize
from scipy.optimize import Bounds
import matplotlib.pyplot as plt
import numpy as np
import math
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import scipy.io

# path to dataset
path = "../../dataset/"

# load one file (input_test1 and input_test2 are ellipses centered at [0,0])
#mat = scipy.io.loadmat(path + 'input_test1.mat')

# load just the x y collumns
#data_mat = mat['data'][:,:2]

#data = [[0]*len(data_mat[:,0])]*2
#data[0] = data_mat[:,0]
#data[1] = data_mat[:,1]

# 2nd example (you need to change the size of the Xdata to 100)
data = [[0]*100]*2
data[0] = np.array([0.500000000000000,0.499013364214136,0.496057350657239,0.491143625364344,0.484291580564316,0.475528258147577,0.464888242944126,0.452413526233010,0.438153340021932,0.422163962751008,0.404508497187474,0.385256621387895,0.364484313710706,0.342273552964344,0.318711994874345,0.293892626146237,0.267913397489498,0.240876837050858,0.212889645782536,0.184062276342339,0.154508497187474,0.124344943582427,0.0936906572928623,0.0626666167821521,0.0313952597646567,-8.04061324838318e-17,-0.0313952597646567,-0.0626666167821522,-0.0936906572928624,-0.124344943582427,-0.154508497187474,-0.184062276342339,-0.212889645782536,-0.240876837050858,-0.267913397489498,-0.293892626146237,-0.318711994874345,-0.342273552964344,-0.364484313710706,-0.385256621387895,-0.404508497187474,-0.422163962751008,-0.438153340021932,-0.452413526233010,-0.464888242944126,-0.475528258147577,-0.484291580564316,-0.491143625364344,-0.496057350657239,-0.499013364214136,-0.500000000000000,-0.499013364214136,-0.496057350657239,-0.491143625364344,-0.484291580564316,-0.475528258147577,-0.464888242944126,-0.452413526233010,-0.438153340021932,-0.422163962751008,-0.404508497187474,-0.385256621387895,-0.364484313710706,-0.342273552964345,-0.318711994874345,-0.293892626146237,-0.267913397489499,-0.240876837050858,-0.212889645782536,-0.184062276342339,-0.154508497187474,-0.124344943582428,-0.0936906572928627,-0.0626666167821523,-0.0313952597646566,-9.18485099360515e-17,0.0313952597646564,0.0626666167821521,0.0936906572928621,0.124344943582427,0.154508497187474,0.184062276342339,0.212889645782536,0.240876837050857,0.267913397489498,0.293892626146236,0.318711994874345,0.342273552964344,0.364484313710706,0.385256621387895,0.404508497187474,0.422163962751007,0.438153340021932,0.452413526233010,0.464888242944126,0.475528258147577,0.484291580564316,0.491143625364344,0.496057350657239,0.499013364214136,0.500000000000000])
data[1] = np.array([0,0.0941857792939701,0.187999850346456,0.281071971878587,0.373034830747282,0.463525491562421,0.552186829027017,0.638668937347609,0.722630511152573,0.803740192468495,0.881677878438710,0.956135984623035,1.02682065889303,1.09345294113212,1.15576986416368,1.21352549156242,1.26649188825302,1.31446002006580,1.35724057869903,1.39466472883238,1.42658477444273,1.45287474169295,1.47343087609303,1.48817205197172,1.49704009264241,1.50000000000000,1.49704009264241,1.48817205197172,1.47343087609303,1.45287474169295,1.42658477444273,1.39466472883238,1.35724057869903,1.31446002006580,1.26649188825302,1.21352549156242,1.15576986416368,1.09345294113212,1.02682065889303,0.956135984623034,0.881677878438710,0.803740192468495,0.722630511152573,0.638668937347609,0.552186829027017,0.463525491562421,0.373034830747282,0.281071971878587,0.187999850346456,0.0941857792939697,1.83697019872103e-16,-0.0941857792939694,-0.187999850346456,-0.281071971878586,-0.373034830747282,-0.463525491562420,-0.552186829027016,-0.638668937347608,-0.722630511152573,-0.803740192468495,-0.881677878438710,-0.956135984623034,-1.02682065889303,-1.09345294113212,-1.15576986416368,-1.21352549156242,-1.26649188825302,-1.31446002006579,-1.35724057869903,-1.39466472883238,-1.42658477444273,-1.45287474169295,-1.47343087609303,-1.48817205197172,-1.49704009264241,-1.50000000000000,-1.49704009264241,-1.48817205197172,-1.47343087609303,-1.45287474169295,-1.42658477444273,-1.39466472883238,-1.35724057869903,-1.31446002006580,-1.26649188825302,-1.21352549156242,-1.15576986416368,-1.09345294113212,-1.02682065889303,-0.956135984623034,-0.881677878438710,-0.803740192468496,-0.722630511152573,-0.638668937347610,-0.552186829027017,-0.463525491562421,-0.373034830747283,-0.281071971878587,-0.187999850346457,-0.0941857792939699,-3.67394039744206e-16])

dt = 1/50
# remove last one
Xdata = [sub[:-1] for sub in data]

# Xdata = np.array(data)
Xvel = np.diff(data)/dt

# convert to polar coordinates
r = np.sqrt(np.power(Xdata[0],2) + np.power(Xdata[1],2))
theta_circle = np.arctan2(Xdata[1], Xdata[0])

# convert to polar velocity coordinates
r_dot = np.sum(Xdata*Xvel, axis=0)/np.sqrt(np.power(Xdata[0],2) + np.power(Xdata[1],2))        # param 1
theta_circle_dot = (Xvel[1]*Xdata[0] - Xdata[1]*Xvel[0])/(np.power(Xdata[0],2) + np.power(Xdata[1],2))   # param 2

def fun(x):

    x_hat = x[3] * math.cos(x[5])* (Xdata[0]) + x[3] * math.sin(x[5]) * (Xdata[1])
    y_hat = -x[4] * math.sin(x[5])* (Xdata[0]) + x[4] * math.cos(x[5]) * (Xdata[1])

    r_ = np.sqrt(np.power(x_hat,2) + np.power(y_hat,2))
    phi = np.arctan2(y_hat, x_hat)

    r__dot = -1 * x[0] * (r_ - x[2])
    phi_dot = x[1]

    xd_hat = r__dot * np.cos(phi) - r_ * phi_dot * np.sin(phi)
    yd_hat = r__dot * np.sin(phi) + r_ * phi_dot * np.cos(phi)

    xdot_d1 = np.cos(x[5]) * (1 / x[3]) * xd_hat - np.sin(x[5]) * (1 / x[4]) * yd_hat
    xdot_d2 = np.sin(x[5]) * (1 / x[3]) * xd_hat + np.cos(x[5]) * (1 / x[4]) * yd_hat

    return np.sum(np.power((r_ - r)/np.linalg.norm(r, ord=1), 2)) + np.sum(np.power((phi - theta_circle)/np.linalg.norm(theta_circle, ord=1), 2)) +  np.sum(np.power((r__dot - r_dot)/np.linalg.norm(r_dot, ord=1), 2)) + np.sum(np.power((phi_dot - theta_circle_dot)/np.linalg.norm(theta_circle_dot, ord=1), 2))


# initial parameters
#  alpha omega radius a b theta
x0 = [1, 1, 0.1, 0.1, 0.1, 0.1]
# bounds
bnds = Bounds([5, -2*math.pi, 0.0001, 1, 1, -2*math.pi], [50, 2*math.pi, 2, np.infty, np.infty, 2*math.pi])

res_robust = minimize(fun, x0, method='SLSQP',  bounds=bnds)
print(res_robust.x)
popt = res_robust.x

## Plotting Results
w = 2
Y, X = np.mgrid[-w:w:0.1, -w:w:0.1]

# compute dynamics
x_hat =  popt[3] * math.cos(popt[5]) * X  + popt[3] * math.sin(popt[5]) * Y
y_hat = -popt[4] * math.sin(popt[5]) * X  + popt[4] * math.cos(popt[5]) * Y

r_ = np.sqrt(np.power(x_hat,2) + np.power(y_hat,2))
phi = np.arctan2(y_hat, x_hat)

r__dot = -1*np.multiply(popt[0], (r_ - popt[2]))
phi_dot = popt[1]

xd_hat = r__dot * np.cos(phi) - r_ * phi_dot * np.sin(phi)
yd_hat = r__dot * np.sin(phi) + r_ * phi_dot * np.cos(phi)

U = math.cos(popt[5]) * (1 / popt[3]) * xd_hat - math.sin(popt[5]) * (1 / popt[4]) * yd_hat
V = math.sin(popt[5]) * (1 / popt[3]) * xd_hat + math.cos(popt[5]) * (1 / popt[4]) * yd_hat

# plotting the data
fig = plt.figure(1)
ax0 = fig.add_subplot()
l1 = ax0.streamplot(X, Y, U, V, density=[2, 2])
ax0.set_title('Limit Cycle')

plt.plot(data[0], data[1], '.r', label='real trajectory')
plt.xlabel('$x$')
plt.ylabel('$y$')
plt.plot()

ax0.legend()
plt.tight_layout()
plt.show()
